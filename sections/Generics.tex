\section*{Generics}
	Generics sind zu vergleichen mit Templates in \texttt{C++}. In Java könnte es auch gelöst werden, indem ein Element mit dem Typ \texttt{Object} entgegen genommen wird, dann ist aber ein Type-Cast notwendig wenn das Objekt, ohne Typinformationsverluste, wieder zurückgenommen werden will.
	\subsection*{Generische Klasse}
		\begin{minipage}[t]{8.5cm}
			\begin{itemize}[noitemsep]
				\item \textbf{Typ-Parameter:} Platzhalter für unbekannten Typ
				\item \textbf{Bei Einsatz:} Typ-Argument muss angegeben werden
			\end{itemize}
		\end{minipage}
		\hspace*{0.25cm}
		\begin{minipage}[t]{4.2cm}
			\textbf{Klasse mit Typ-Parameter}	
			\lstinputlisting{code/Generics_definition.java}
		\end{minipage}
		\hspace*{0.25cm}
		\begin{minipage}[t]{5.3cm}
			\textbf{Einsatz mit Typ-Argument}
			\lstinputlisting{code/Generics_usage.java}
		\end{minipage}
	\begin{minipage}[t]{7cm}
		\subsection*{Generische Interfaces}
		\lstinputlisting{code/Generics_interface.java}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{11.3cm}
		\subsection*{Generische Methoden}
		\lstinputlisting{code/Generics_methods.java}
	\end{minipage}
	\begin{minipage}[t]{9cm}
		\subsection*{Type-Bound}
		\begin{itemize}[noitemsep]
			\item extends-Klausel bei Typ-Parameter
			\item Typ-Argument muss Subtyp von Graphic sein
		\end{itemize}
		\lstinputlisting{code/Generics_TypeBound.java}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{9.3cm}
		\subsection*{Type Inference}
		Generische Methoden ohne Typ-Argument aufrufen $\rightarrow$ wird automatisch von Methodenargument erkannt.
		\lstinputlisting{code/Generics_TypeInference.java}
	\end{minipage}
	