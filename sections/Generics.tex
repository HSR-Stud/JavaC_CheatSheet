\newpage
\section*{Generics}
	\vspace{-0.7cm}
	Generics sind zu vergleichen mit Templates in \texttt{C++}. In Java könnte es auch gelöst werden, indem ein Element mit dem Typ \texttt{Object} entgegen genommen wird, dann ist aber ein Type-Cast notwendig wenn das Objekt, ohne Typinformationsverluste, wieder zurückgenommen werden will.\\
	\begin{minipage}[t]{9cm}
		\subsection*{Generische Klasse}
		$<$Typ-Parameter$>$: Platzhalter für unbekannten Typ	
		\lstinputlisting{code/Generics_definition.java}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{9.3cm}
		\subsection*{Einsatz mit Typ-Argument}
		$<$Typ-Argument$>$: muss angegeben werden
		\lstinputlisting{code/Generics_usage.java}
	\end{minipage}
	
	\begin{minipage}[t]{7cm}
		\subsection*{Generische Interfaces}
		\lstinputlisting{code/Generics_interface.java}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{11.3cm}
		\subsection*{Generische Methoden}
		\lstinputlisting{code/Generics_methods.java}
	\end{minipage}

	\begin{minipage}[t]{9cm}
		\subsection*{Type-Bound}
		\begin{itemize}[noitemsep]
			\item extends-Klausel bei Typ-Parameter
			\item Typ-Argument muss Subtyp von Graphic sein
		\end{itemize}
		\lstinputlisting{code/Generics_TypeBound.java}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{9.3cm}
		\subsection*{Type Inference}
		Generische Methoden ohne Typ-Argument aufrufen $\rightarrow$ wird automatisch von Methodenargument erkannt.
		\lstinputlisting{code/Generics_TypeInference.java}
	\end{minipage}